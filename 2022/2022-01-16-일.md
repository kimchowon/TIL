~~음...~~

# 함수형 프로그래밍이란

(정리 예정)

## 함수형 프로그래밍 조건

1. 인풋이 있고 아웃풋을 return하는 형태의 함수
2. 외부 환경으로부터 철저히 독립적
    1. 외부 변수에 값을 쓰지도 참조하지도 않는다.
    2. 오로지 자신에게 주어진 인풋을 이용하여 정해진 작업을 한다.
3. 같은 인풋에 있어서 언제나 동일한 아웃풋을 생산
    1. 외부 요인의 영향을 받지 않기 때문에 철저히 들어오는 인풋에 따른 결과물이 만들어진다. 이를 순수함수라고 한다.

## 함수형 프로그래밍 사용 효과

 함수형 프로그래밍을 이용하면 얻을 수 있는 효과는 다음과 같다. 

- 함수 자체가 독립적이며 Side-Effect가 없기 때문에 Thread에 안전성을 보장받을 수 있다.
- Thread에 안정성을 보장받아 병렬 처리를 동기화 없이 진행할 수 있다.

\>> 부가 설명

함수형 프로그래밍이 주목받게 된 이유 중 하나는 어떤 함수의 동작에 의해 프로그램 내 특정 상태가 변경되는 부수 효과로부터 자유롭다는 것. 만약 부수 효과가 일어난다면 그로 인해 변경된 상태는 다른 동작들에게 영향을 미칠 수 있다. 이러한 예시로 두 개의 쓰레드가 한 변수에 접근할 때 발생하는 동기화 문제가 있다.

함수형 프로그래밍은, 함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 오류를 방지한다. 문제의 소지가 있는 일은 하지 않는 코딩 방식이라는 것.

## 함수형 프로그래밍의 대표적 특징과 요소

1. 함수형 프로그래밍은 ‘선언형’이다.
    1. 프로그램이 어떤 방법으로 해야 하는지를 나타내기보다 무엇과 같은지를 설명하는 경우
    2. 함수형 방식으로 짜인 함수, ‘순수 함수’들은 인풋만 똑같으면 절대 다른 요인의 의한 변수가 없다. 
    때문에 순수 함수에 A인자를 넣으면 무조건 결과는 B이다가 성립한다.
2. 함수도 ‘값’이다.
    1. 명령형 방식
        1. 변수만 = 키워드로 값을 대입하여 ‘이거는 이거다’로 생각.
        2.  함수는 이를 처리하는 행위적인 개념
    2. 함수형 프로그래밍에서는 함수도 ‘값’으로 보고 프로그래밍.
    3. 인자 없이 오로지 함수, 함수들의 연결만으로는 숫자나 문자열, boolean, 객체같은 값이 만들어지지는 않음.
        1. ex) 자바 스크립트 코드
        
        ```java
        // 인풋 = number, 아웃풋 = number * 2
        // 인풋, 아웃풋 외에는 아무 부수적인 값도 주지 말아야 한다. 
        var double_it = function(number) {
        	return number * 2;
        }
        
        // 화살표 함수 버전
        const double_it = (number) => number * 2;
        
        // 함수 호출1
        return double_it; // 인풋이 없으니 아웃풋이 없다.
        
        // 함수 호출2
        return double_it(2); // 인풋=2, 아웃풋=6
        ```
        
        인풋(인자)가 있어야만 아웃풋을 리턴하지만, 함수가 인풋으로 하는 일은 일정하기 때문에 절대 예측 가능한 값을 내게 될 상태라는 ‘값’으로 함수를 생각할 수 있는 것.
        
3. 고계 함수
    1. 고계 함수: 인자로 다른 함수를 받아 결과값을 내보내는 함수.
    2. 함수를 ‘값’으로 바라볼 수 있다면 함수도 다른 함수에 인자로 넣어줄 수 있음.
    
    ```java
    // 세번째 인자 op는 함수
    var calc = function(num1, num2, op) {
    	return op(num1, num2);
    }
    
    // 화살표 함수 버전
    const calc = (num1, num2, op) => op(num1, num2);
    
    // op 인자 부분에 아래와 같은 함수들을 대입할 수 있음.
    const add = (num1, num2) => num1 + num2;
    const multiply = (num1, num2) => num1 * num2;
    const power = (num1, num2) => Math.pow(num2, num1);
    ```

    <br/>
    
    다른 함수를 반환하는 함수도 고계함수에 속함. 프로그램이 동작하는 중에 함수가 만들어진다. <br/>
    ```java
    // 결과값으로 함수를 반환하는 고계함수
    const calcWith2 = (op) => (num) => op(2, num);

    const add = (num1, num2) => num1 + num2;
    const multiply = (num1, num2) => num1 * num2;

    // add2, multiply2는 함수
    const add2 = calcWith2(add);
    const multiply2 = calcWith2(multiply);

    add2(3); // 5
    multiply2(3); // 6
    ```

1. 함수 컴비네이터
    1. 배열이나 리스트 같은 컬렉션에서 자주 사용되는 기능
    2. 자바에서는 stream에서 filter, map, sort 등을 이용하여 사용할 수 있음.
    3. ex) 교내 알바 학생들을 모집하는데 선발 기준은 이과생으로 선착순 3명.
          뽑힌 학생들의 이름, 괄호 안에 전공을 표시해서 스페이스로 나뉜 문자열을 출력하는 작업.
    - 함수형 프로그래밍이 아닌 일반 방식으로 작성 한 코드 예시
    
    ```jsx
    var students = [
    	new Students("홍길동", "문과", "문학"),
    	new Students("전우치", "이과", "기계"),
    	new Students("임꺽정", "이과", "화학"),
    	new Students("일지매", "문과", "언론"),
    	new Students("장길산", "예체능", "체조"),
    	new Students("연흥부", "이과", "컴퓨터"),
    	new Students("연놀부", "이과", "수학"),
    	new Students("옹고집", "문과", "경영"),
    	new Students("이몽룡", "문과", "정치"),
    	new Students("연오랑", "예체능", "사진")
    ]
    
    var filtered = []; // 이과생들만 담을 배열, 외부 변수
    
    // 1. 이과 학생들만 뽑아서 filtered 배열에 담음
    for(var i = 0; i < students.length; i++) {
    	if(students[i].divistion === "이과") {
    		filtered.push(students[i]); // 외부 변수값 변경
    	}
    }
    
    // 2. 이과 학생들중 선착순 3명만 자름
    filtered = filtered.splice(0, 3);
    
    // 3. 이름 + '(' + 전공 + ')' 을 이어붙인 문자열 생성
     var result = "";
    for(var i = 0; i < filtered.length; i++) {
    	result += '${filtered[i].name}(${filtered[i].major})';
    }
    
    console.log(result);
    ```
    
    → for문이 빈번하고 외부 변수를 변경하는 부수효과(side-effect)가 발생한다. 
    
    - 함수 컴비네이터 사용한 예시 (scala 코드)
    
    ```scala
    println(
    	students
    		.filter(i => i.division == "이과")
    		.take(3)
    		.map(i => s"${i.name}(${i.major})")
    )
    ```
    
    - filter : 함수 인자로 주어진 기준을 충족하는 요소들만 골라서 리스트로 만들어 반환 → 고계 함수
    - take: 인자로 주어진 갯수만큼만 뽑아 반환
    - map: 각 요소들을 인자로 주어진 함수에 넣어서 그 결과물 형식으로 변환
    

## 객체 지향 프로그래밍 vs 함수형 프로그래밍

객체 지향 프로그래밍과 함수형 프로그래밍은 대립 관계가 아니다.

객체 지향 프로그래밍을 모두 100% 함수형 기준으로 바꿀 수는 없다. 하지만 적어도 일정 단위의 작업에 있어서는 부수효과 없이 안정적이고 예측 가능한 프로그램을 짜는게 함수형 프로그래밍이다. 프로세서의 발전 속도가 사용자의 필요에 뒤쳐지면서 멀티 코어에 의한 멀티 프로세싱이 중요해진 오늘날 함수형 프로그래밍이 그래서 더더욱 주목받고 있다. 때문에 객체 지향 프로그래밍과 함수형 프로그래밍을 적절히 함께 사용하면 된다.
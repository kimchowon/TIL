# 2.JVM 구조

JVM은 크게 4가지 영역으로 나눌 수 있다.

1. 클래스 로더 시스템
2. 메모리
3. 실행 엔진
4. JNI & 네이티브 메소드 라이브러리

<img src="https://user-images.githubusercontent.com/52793122/149522397-803d869f-3281-4a63-855c-d9b2066f98d4.jpg"  width="800" height="550"/>

<br/>
<br/>

## 1. 클래스 로더 시스템

- .class에서 바이트 코드를 읽고 메모리에 저장
- 하는일은 3가지가 있다.
    - 로딩: 클래스에서 읽어오는 과정
    - 링크: 레퍼런스를 연결하는 과정
    - 초기화: static 값들을 초기화 및 변수에 할당

<br/>

## 2. 메모리

다른 모든 영역에서 공유하는 영역

1. 메소드 영역: 클래스 수준의 정보(클래스 이름, 부모 클래스 이름, 메소드, 변수) 저장.
2. 힙 영역: 객체(실제 인스턴스)를 저장

각 쓰레드에 국한. 다른 영역끼리 공유하지 않는 영역

1. 스택 영역
    1. 쓰레드마다 런타임 스택을 만든다. 
    2. 스택안에 메소드 호출을 스택 프레임이라는 블럭으로 쌓는다. 
    3. 쓰레드가 종료하면 런타임 스택도 사라진다.
2. PC(Program Counter) 레지스터
    1. 스택 영역에 쌓여있는 메소드 중 스레드가 현재 실행할 스택 프레임을 가리키는 포인터가 생성
3. 네이티브 메소드 스택: 네이티브 메소드를 호출하기 위한 스택
    1. 네이티브 메소드: Java이외에 c, c++로 작성된 메소드
    2. ex) Thread.currentThread();
    
    ```bash
    public static native Thread currentThread();
    ```
<br/>

## 3. 실행 엔진

1. 인터프리터
    1. 바이트 코드를 한 줄씩 읽어 기계가 이해할 수 있는 코드로 컴파일하여 실행
    2. 그런데 한 줄씩 읽다보면 중복되는 코드가 등장할 수 있음. 매번 읽어서 컴파일 하는가? 
        1. JIT 컴파일러로 성능 향상
2. JIT 컴파일러
    1. 인터프리터 효율을 높이기 위해, 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러로 반복되는 코드들을 모두 네이티브 코드로 바꿔둔다. 
    2. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 실행한다. 
3. GC(Garbage Collector)
    1. 더 이상 참조되지 않는 객체를 모아서 정리
    2. 인터프리터나 JIT 컴파일러는 동작 방식을 이해하기만 하면 되지만 GC는 이해 뿐만 아니라 개발자가 경우에 따라 커스터마이징, 옵션 조정 등을 해야 한다. 또는 애플리케이션을 실행할 때 적절한 GC를 선택할 수도 있다. 
    3. GC를 크게 나누면 스레드풀을 줄이는 GC, Stop-The-World를 줄이는 GC가 있다. 서버 운영중에 많은 객체를 생성하고 응답 시간이 중요한 경우에는 Stop-The-World, 즉 GC가 실행될 때 멈춤 현상을 최소화하는 GC를 사용하는 것이 좋다. 

<br/>

## 4. JNI & 네이티브 메소드 라이브러리

1. JNI(Java Native Interface)
    1. 자바 애플리케이션에서 C, C++, 어셈블리로 작성된 함수를 사용할 수 있는 방법 제공
    2. Native 키워드를 사용한 메소드 호출
    3. 네이티브 메소드 라이브러리는 JNI를 통해 호출
2. 네이티브 메소드 라이브러리
    1. C, C++로 작성된 라이브러리
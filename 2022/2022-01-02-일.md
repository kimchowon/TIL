# 2장. 객체 생성과 파괴

## 1. 생성자 대신 정적 팩터리 메서드를 고려하라

### 정적 팩터리 메서드

클래스의 인스턴스를 반환하는 정적 메서드

### 정적 팩터리 메서드의 장점

1. 이름을 가질 수 있다.

클래스의 생성자를 생성할 때는 단순히 new (클래스명) 으로 반환될 객체의 특성을 제대로 설명하지 못한다. 

반면, 정적 팩터리 메서드는 반환될 객체의 특성을 메서드명으로 쉽게 묘사할 수 있다. 

Effective Java에서 예시로 드는 BigInteger 클래스이다.

BigInteger 클래스에서 제공하는 값이 소수인 BigInteger를 반환하는 생성자이다. 

```java
public BigInteger(int bitLength, int certainty, Random rnd) {
        BigInteger prime;

        if (bitLength < 2)
            throw new ArithmeticException("bitLength < 2");
        prime = (bitLength < SMALL_PRIME_THRESHOLD
                                ? smallPrime(bitLength, certainty, rnd)
                                : largePrime(bitLength, certainty, rnd));
        signum = 1;
        mag = prime.mag;
    }
```

아래도 마찬가지고 값이 소수인 BigInteger를 반환한다. 그런데 생성자가 아닌 정적 팩터리 메서드이다. 

메서드명을 구체화하여 소수인 BigInteger를 반환한다고 쉽게 묘사하였다. 

```java
public static BigInteger probablePrime(int bitLength, Random rnd) {
        if (bitLength < 2)
            throw new ArithmeticException("bitLength < 2");

				// 여길 깊게 들어가보면 결국 new BingInteger(..) 이다. :)
        return (bitLength < SMALL_PRIME_THRESHOLD ?
                smallPrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd) :
                largePrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd));
    }
```

1. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다. 

불변 클래스(immutable class)같은 경우에는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다. 

무슨 말인지 예시를 통해 보자.

다음은 Boolean 클래스의 valueOf(boolean) 메서드이다.

Boolean.valueOf 메서드를 호출하면 새롭게 객체를 생성하지 않는다. 

```java
Boolean aBoolean = Boolean.valueOf(true);

public static Boolean valueOf(boolean b) {
        return (b ? TRUE : FALSE);
    }
```

TRUE, FALSE를 상수로 정의해놓고 이를 반환 할 뿐이다. 

이처럼 같은 객체가 자주 요청되는 상황이면서 해당 클래스가 immutable이라면 성능을 상당히 끌어올려 준다. 

```java
public final class Boolean implements java.io.Serializable,
                                      Comparable<Boolean>
{
    /**
     * The {@code Boolean} object corresponding to the primitive
     * value {@code true}.
     */
    public static final Boolean TRUE = new Boolean(true);

    /**
     * The {@code Boolean} object corresponding to the primitive
     * value {@code false}.
     */
    public static final Boolean FALSE = new Boolean(false);

		...
}
```

- [ ]  플라이웨이트 패턴 공부

1. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 

반환할 객체의 클래스를 자유롭게 선택할 수 있다. 

아마 다형성을 이용한 구현 방법에 적용되는 장점인 듯 하다. 

예시를 보자.(내가 만든 예시라서 오류가 있을 수도 있다.)

```java
public interface Animal {
    String sound();
}

public class Dog implements Animal{

    @Override
    public String sound() {
        return "멍멍";
    }
}

public class Cat implements Animal {
    @Override
    public String sound() {
        return "야옹";
    }
}
```

```java
public class Zoo {

    public static final String DOG_SOUND = "멍멍";
    public static final String CAT_SOUND = "냐옹";

		// 정적 팩터리 메서드
    public static Animal animal(String sound) {
        switch (sound) {
            case DOG_SOUND:
                return new Dog();
            case CAT_SOUND:
                return new Cat();
        }
        throw new IllegalArgumentException();
    }
}
```

4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 

반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관이 없다.

Java의 EnumSet 클래스는 생성자 없이 정적 팩터리 메서드만 제공한다. 

매개 변수로 주어지는 원소 개수가 64개 이하면 RegularEnumSet을, 그 이상이면 JumboEnumSet 인스턴스를 반환한다. 

RegularEnumSet, JumboEnumSet은 둘다 EnumSet 클래스를 상속하는 자식 클래스이다. 

3번에서 내가 만든 예제도 같은 맥락이다. 

```java
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
        Enum<?>[] universe = getUniverse(elementType);
        if (universe == null)
            throw new ClassCastException(elementType + " not an enum");

        if (universe.length <= 64)
            return new RegularEnumSet<>(elementType, universe);
        else
            return new JumboEnumSet<>(elementType, universe);
    }
```

5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
- 책 내용
    
    서비스 제공자 프레임워크
    
    - 대표적인 서비스 제공자 프레임워크: JDBC
    - 제공자: 서비스의 구현체
    - 서비스 제공자 프레임워크의 3가지 핵심 컴포넌트
        1. 서비스 인터페이스
        2. 제공자 등록 API
        3. 서비스 접근 API
            1. 클라이언트는 서비스 접근 API를 사용할 때 원하는 구현체의 조건을 명시할 수 있다. 
            조건을 명시하지 않으면 기본 구현체를 반환하거나 지언하는 구현체들을 하나씩 돌아가며 반환한다.
    - 4번째 컴포넌트: 서비스 제공자 인터페이스
        - 서비스 인터페이스의 인스턴스를 생성하는 팩터리 객체를 설명해준다.
    - JDBC에서 컴포넌트를 담당하는 클래스및 메서드
        - 서비스 인터페이스: Connection
        - 제공자 등록 API: DriverManager.registerDriver
        - 서비스 접근 API: DriverManager.getConnection
        - 서비스 제공자 인터페이스: Driver
    
    ~~흠.. 이게 어떤 의미인지 잘 와닿지 않는다.~~
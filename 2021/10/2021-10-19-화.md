Java는 이런 문제에 대한 솔루션을 제공하는데 다음 섹션을 보자 

## Java volatile Happens-Before 보장

명령어 재정렬 문제를 해결하기 위해, Java volatile 키워드는 가시성 보장 외에도 "happens-before" 보장을 제공한다. 이는 다음을 보장한다. 

- description (오우..)
    - Reads from and writes to other variables cannot be reordered to occur after a write to a volatile variable, if the reads / writes originally occurred before the write to the volatile variable.
    The reads / writes before a write to a volatile variable are guaranteed to "happen before" the write to the volatile variable. Notice that it is still possible for e.g. reads / writes of other variables located after a write to a volatile to be reordered to occur before that write to the volatile. Just not the other way around. From after to before is allowed, but from before to after is not allowed.
    - Reads from and writes to other variables cannot be reordered to occur before a read of a volatile variable, if the reads / writes originally occurred after the read of the volatile variable. Notice that it is possible for reads of other variables that occur before the read of a volatile variable can be reordered to occur after the read of the volatile. Just not the other way around. From before to after is allowed, but from after to before is not allowed.

번역을 해봐도 이해가 잘 가지 않는다. 이해가 쉽게 요약을 잘 해놓으신 블로그가 있어 참고하였다.

(참고: [https://parkcheolu.tistory.com/16](https://parkcheolu.tistory.com/16))

### volatile 키워드의 Happens-Before 성질

"volatile 변수에 대한 읽기/쓰기 명령은 JVM 에 의해 재정리되지 않음을 보장한다는 의미이다. volatile 변수에 대한 읽기/쓰기 명령을 기준으로, 이 변수 전에 존재하는 다른 명령들은 자기들끼리 얼마든지 재정리 될 수 있다. 그리고 이 변수 뒤에 존재하는 다른 명령들 또한 자기들끼리 재정리 될 수 있다. 다만, volatile 변수에 대한 명령 이전/이후에 존재한다는 그 전제는 반드시 지켜진다."

## volatile이 항상 충분한 것은 아니다.

volatile 키워드가 모든 읽기/쓰기를 메인 메모리에서 직접 이뤄지도록 보장하더라도, volatile 변수를 선언하는 것만으로 충분하지 않는 상황은 여전히 일어날 수 있다.

> references
[http://tutorials.jenkov.com/java-concurrency/volatile.html](http://tutorials.jenkov.com/java-concurrency/volatile.html)
>